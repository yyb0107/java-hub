# 代理模式

---

## 什么是代理模式
由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。

## 为什么用代理模式
上面说的某些原因包括：
目标对象的功能需要增强；
目标对象需要进行保护；

## 如何使用代理模式
### 静态代理
代理对象持有目标对象的一个引用，在这个基础上对目标对象的进行功能上的增强，在平时的代码中我们会有意无意的用到。
```java
public class JobHunter {
    Person person;

    public JobHunter(Person person) {
        this.person = person;
    }

    public void findJob() {
        before();
        person.findJob("static");
        after();
    }

    private void after() {
        System.out.println("找到合适的工作了。");
    }

    private void before() {
        System.out.println("根据需求搜集信息……");
    }
}
```
### 动态代理
动态代理主要有`JDK动态代理`和`CGLIB动态代理`
它们的共性就是都会对根据目标对象动态生成一个代理类的class文件,通过内部编译并重新初始化的一个新的对象，这个就是我们的代理对象。
```java
public class JobHunter implements MethodInterceptor {
    public Object getInstance(Class clazz) {
        //这里就是生成代理对象的代码
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(clazz);
        enhancer.setCallback(this);
        return enhancer.create();
    }

    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        before();
        Object obj = methodProxy.invokeSuper(o,objects);
        after();
        return obj;
    }

    private void after() {
        System.out.println("这里是CGLib,找到合适的工作了。");
    }

    private void before() {
        System.out.println("这里是CGLib,根据需求搜集信息……");
    }
}
```

--|jdk代理|CGlib代理
----|----|----
要求|目标对象必须实现一个接口，jdk根据接口重写方法|目标对象在继承关系上没有限制，cglib根据当前类来重写方法
效率|JDK Proxy生成代理的逻辑简单，执行效率相对要低，每次都要反射动态调用|CGLib 生成代理逻辑更复杂，效率,调用效率更高，生成一个包含了所有的逻辑的FastClass，不再需要反射调用
> cglib不能代理final的方法·






